<!DOCTYPE html><html><head><style>
.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { color: #008000; font-weight: bold } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #808080 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0040D0 } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mf { color: #000033 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #000033 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.il { color: #666666 } /* Literal.Number.Integer.Long */

.wikilink {
    text-decoration: none;
    background-color: #F6F0AC;
    border-radius: 4px;
    text-shadow: 1px 1px white;
    padding-left: 3px;
    padding-right: 3px;
    font-family: monospace;
}

dt {
    margin-top: 1em;
    font-family: monospace;
    font-size: 110%;
    font-weight: bold;
}

body {
    color: #303030;
    font-size: 14px;
    line-height: 1.42857;
    margin: 50px;
    padding: 50px;
}

pre {
    background: #F5F5F5;
    border: 1px solid #C0C0C0;
    border-radius: 3px;
    padding: 5px 10px;
}

code {
    background: #E8E8E8;
    border: 0px solid #C0C0C0;
    border-radius: 3px;
    padding: 1px 3px;
    font-size: 90%;
}

</style></head><title>The tab programming language.</title><body>
<h1 id="the-tab-cookbook">The tab cookbook</h1>
<p>This is an example list of useful <code>tab</code> programs.</p>
<h2 id="working-with-lines-and-words">Working with lines and words:</h2>
<h4 id="count-the-number-of-lines-in-a-file">Count the number of lines in a file:</h4>
<div class="codehilite"><pre><span></span>count(@)
</pre></div>


<h4 id="output-the-longest-line-in-a-file">Output the longest line in a file:</h4>
<div class="codehilite"><pre><span></span>max([ count(@), @ ])~1
</pre></div>


<h4 id="output-the-three-longest-lines-in-a-file">Output the three longest lines in a file:</h4>
<div class="codehilite"><pre><span></span>[ @~1 : sort([ count(@), @ ])[-3,-1] ]
</pre></div>


<h4 id="output-the-most-common-english-word-in-a-file">Output the most common English word in a file:</h4>
<div class="codehilite"><pre><span></span>freq={ @ -&gt; sum.1 : :[grep(@,&quot;[A-Za-z0-9]+&quot;)] }, second.max.flip.freq
</pre></div>


<h4 id="output-the-counts-of-top-ten-most-common-bytes-in-a-file">Output the counts of top ten most common bytes in a file:</h4>
<div class="codehilite"><pre><span></span>freq={ @ -&gt; sum.1 : :[bytes.@] }, [ string.array.@~1, @~0 : (sort.flip.freq)[-10,-1] ]
</pre></div>


<h4 id="the-histogram-of-english-word-frequencies-by-word-lengths">The histogram of English word frequencies by word lengths:</h4>
<div class="codehilite"><pre><span></span>freq={ count.@ -&gt; sum.1 : :[grep(@,&quot;[A-Za-z0-9]+&quot;)] }, sort.freq
</pre></div>


<h4 id="same-histogram-but-also-with-the-words-themselves">Same histogram, but also with the words themselves:</h4>
<div class="codehilite"><pre><span></span>freq={ count.@ -&gt; sum.1, {tolower.@} : :[grep(@,&quot;[A-Za-z0-9]+&quot;)] },
def f first.@,
def s second.@,
sort.[ f.@, f.s.@, join(f.s.s.@, &quot;,&quot;) : freq]
</pre></div>


<h4 id="all-english-words-following-the-word-the">All English words following the word &lsquo;the&rsquo;:</h4>
<div class="codehilite"><pre><span></span>?[ (tolower.first.@) == &quot;the&quot;, second.@ : pairs( :[grep(@,&quot;[A-Za-z0-9]+&quot;)] ) ]
</pre></div>


<h2 id="sampling-data-randomly-from-files">Sampling data randomly from files:</h2>
<h4 id="output-four-random-lines-from-a-file">Output four random lines from a file:</h4>
<div class="codehilite"><pre><span></span>sample(4, @)
</pre></div>


<h4 id="check-if-there-is-an-empty-line-among-four-random-lines-from-a-file">Check if there is an empty line among four random lines from a file:</h4>
<div class="codehilite"><pre><span></span>sum([ count(@) == 0 : sample(4, @) ]) &gt; 0
</pre></div>


<h4 id="sample-four-lines-from-filetxt-one-hundred-times-and-output-the-histogram-of-number-of-empty-lines">Sample four lines from <code>file.txt</code> one hundred times and output the histogram of number of empty lines:</h4>
<div class="codehilite"><pre><span></span>def empties sum([ count(@) == 0 : sample(4, @) ]),
{ empties.open.&quot;file.txt&quot; -&gt; sum.1 : count(100) }
</pre></div>


<h2 id="basic-math-and-loops">Basic math and loops:</h2>
<h4 id="a-sine-and-cose-table">A sine and cose table:</h4>
<div class="codehilite"><pre><span></span>[ sin.@, cos.@ : count(0.0, 2*pi(), pi()/8) ]
</pre></div>


<h2 id="numeric-data-aggregation">Numeric data aggregation:</h2>
<p>For the next few examples let&rsquo;s use an input file that looks something like this:</p>
<div class="codehilite"><pre><span></span>1948    12  11  24
1948    12  12  19
1948    12  13  -74
1948    12  14  -56
</pre></div>


<p>The first three fields are the year, month and day. The fourth field is the daily max temperature in units of 0.1 degrees Celcius.</p>
<h4 id="the-average-mean-of-the-temperature-aggregated-by-year">The average (mean) of the temperature, aggregated by year:</h4>
<div class="codehilite"><pre><span></span>{ x=cut(@,&quot;\t&quot;), x~0 -&gt; avg.real.x~3 }
</pre></div>


<h4 id="as-above-except-also-with-the-median">As above, except also with the median:</h4>
<div class="codehilite"><pre><span></span>data={ x=cut(@,&quot;\t&quot;), v=real.x~3, x~0 -&gt; avg.v, sort.v }, [ @~0, @~1~0, @~1~1~0.5 : data ]
</pre></div>


<h4 id="a-histogram-of-the-temperature-grouped-by-buckets-of-ten-degrees">A histogram of the temperature, grouped by buckets of ten degrees:</h4>
<div class="codehilite"><pre><span></span>sort.{ x=cut(@,&quot;\t&quot;), 100*int(real(x~3)/100) -&gt; sum.1 }
</pre></div>


<h4 id="check-if-the-distribution-of-temperature-matches-a-sampled-normal-distribution">Check if the distribution of temperature matches a (sampled) normal distribution:</h4>
<div class="codehilite"><pre><span></span>temps=[. real.cut(@,&quot;\t&quot;,3) .],
u=mean.temps, s=stddev.temps, a=min.temps, b=max.temps,
sort.{ bucket(@~0, a, b, 5) -&gt; sum.@~1, sum.@~2 :
       :seq([ @, 1, 0 : temps ], [ normal(u,s), 0, 1 : count.count.temps ]) }
</pre></div>


<h4 id="find-temperature-outliers-more-than-3-standard-deviations-away-from-mean-and-group-them-by-year">Find temperature outliers (more than 3 standard deviations away from mean) and group them by year:</h4>
<div class="codehilite"><pre><span></span>temps=[. x=cut(@,&quot;\t&quot;), uint.x~0, real.x~3 .],
sd=stddev.[@~1 : temps],
{ @~0 -&gt; sum.1 : ?[@~1 &gt; 3*sd, @ : temps] }
</pre></div>


<h4 id="find-years-with-spotty-temperature-records-where-the-number-of-measurements-taken-is-more-than-one-standard-deviation-away-from-the-average-year">Find years with spotty temperature records &ndash; where the number of measurements taken is more than one standard deviation away from the average year:</h4>
<div class="codehilite"><pre><span></span>y_n={ uint.cut(@,&quot;\t&quot;,0) -&gt; sum.1 },
u=mean.second.y_n, sd=stddev.second.y_n,
?[ abs(@~1 - u) &gt; sd, @~0 : y_n ]
</pre></div>


<h4 id="group-temperatures-by-year-and-month-and-find-the-mean-and-median-for-september-1998">Group temperatures by year and month, and find the mean and median for September 1998:</h4>
<div class="codehilite"><pre><span></span>t={ x=cut(@,&quot;\t&quot;), uint.x~1 -&gt; map(uint.x~0, sort.real.x~3) }~9~1998, mean.t, t~0.5
</pre></div>


<h4 id="same-as-above-but-compare-it-to-the-mean-and-median-across-all-septembers">Same as above, but compare it to the mean and median across all Septembers:</h4>
<div class="codehilite"><pre><span></span>t={ x=cut(@,&quot;\t&quot;), uint.x~1 -&gt; map(uint.x~0, sort.real.x~3) }~9,
mean.t~1998, t~1998~0.5,
mean.flatten.second.t, (sort.flatten.second.t)~0.5
</pre></div>


<h4 id="average-september-temperatures-by-year">Average September temperatures by year:</h4>
<div class="codehilite"><pre><span></span>sort.map.?[ x=cut(@,&quot;\t&quot;), (uint.x~1) == 9, uint.x~0, avg.real.x~3 ]
</pre></div>


<dl>
<dd>pipe the output to <code>gnuplot -p -e "plot '-' with lines"</code> to see a graph</dd>
</dl>
<h4 id="moving-average-of-september-temperatures-over-10-previous-years">Moving average of September temperatures, over 10 previous years:</h4>
<div class="codehilite"><pre><span></span>t=sort.map.?[ x=cut(@,&quot;\t&quot;), (uint.x~1) == 9, uint.x~0, avg.real.x~3 ],
sort.{ @~(-1)~0 -&gt; avg.second.seq.@ : ngrams(seq.t, 10) }
</pre></div>


<h4 id="calculate-the-average-difference-between-this-days-temperature-and-the-temperature-on-the-first-of-the-month">Calculate the average difference between this day&rsquo;s temperature and the temperature on the first of the month:</h4>
<div class="codehilite"><pre><span></span>sort.{ x=cut(@,&quot;\t&quot;), t=(real.x~3)/10, uint.x~1 -&gt; avg(t - box(x~2 == &quot;1&quot;, t)~0) }
</pre></div>


<h2 id="working-with-ad-hoc-text-formats">Working with ad-hoc text formats:</h2>
<h4 id="convert-mysql-output-to-a-machine-readable-one">Convert MySQL output to a machine-readable one:</h4>
<div class="codehilite"><pre><span></span>[ join(recut(@, &quot; *\\| *&quot;)[1,-2], &quot;\t&quot;) : skip(grepif(@, &quot;^\\| &quot;), 1) ]
</pre></div>


<h4 id="parse-a-log-file-where-every-line-is-a-json-object">Parse a log file where every line is a JSON object:</h4>
<div class="codehilite"><pre><span></span>regex = &#39;&quot;([^&quot;]+)&quot; *: *([0-9.]+)|&quot;([^&quot;]+)&quot;&#39;,
def split ?[ count.@, @ : grep(@, regex) ],
[ map(stripe(pairs.split.@, 2))~&quot;response&quot; ]
</pre></div>


<dl>
<dd>You will need to add extra backslashes if you want to enter that regex via a shell command line.</dd>
</dl>
<h4 id="given-a-file-with-a-url-on-each-line-find-the-hostnames">Given a file with a URL on each line, find the hostnames:</h4>
<div class="codehilite"><pre><span></span>{ grep(@, &quot;//([^/]*)/&quot;)~0 -&gt; sum.1 }
</pre></div>


<h4 id="parse-the-get-parameters-in-a-file-of-urls">Parse the GET parameters in a file of URLs:</h4>
<div class="codehilite"><pre><span></span>regex = &quot;[?&amp;]([^&amp;]+)=([^&amp;]+)&quot;;
def urlgetparams map.stripe(pairs.[@ : grep(@, regex) ], 2);
[ urlgetparams.@ ]
</pre></div>


<h4 id="same-as-above-but-find-the-most-popular-get-parameter">Same as above, but find the most popular GET parameter:</h4>
<div class="codehilite"><pre><span></span>regex = &quot;[?&amp;]([^&amp;]+)=([^&amp;]+)&quot;;
def urlgetparams map.stripe(pairs.[@ : grep(@, regex) ], 2);
second.max.flip.{ @ -&gt; sum.1 : :[ first.urlgetparams.@ ] }
</pre></div>


<h4 id="another-implementation-of-same-as-above">Another implementation of same as above:</h4>
<div class="codehilite"><pre><span></span>def urlgetparams map.[ take.@, take(@,&quot;&quot;) : explode.seq.recut(@, &quot;[?&amp;=]&quot;)[1,-1] ];
second.max.flip.{ @ -&gt; sum.1 : :[ first.urlgetparams.@ ] }
</pre></div>


<h2 id="working-with-multi-line-data">Working with multi-line data:</h2>
<h4 id="double-space-a-file">Double-space a file:</h4>
<div class="codehilite"><pre><span></span>[ seq(@, &quot;&quot;) ]
</pre></div>


<h4 id="glue-every-pair-of-lines-in-a-file-together">Glue every pair of lines in a file together:</h4>
<div class="codehilite"><pre><span></span>[ join(head(@, 2), &quot;\t&quot;) : explode.@ ]
</pre></div>


<h4 id="count-the-number-of-lines-in-every-paragraph-in-a-file">Count the number of lines in every paragraph in a file:</h4>
<div class="codehilite"><pre><span></span>[ count.while.[ @ != &quot;&quot;, @ ] : explode.@ ]
</pre></div>


<h4 id="remove-duplicate-lines-like-the-unix-tool-uniq">Remove duplicate lines, like the Unix tool <code>uniq</code>:</h4>
<div class="codehilite"><pre><span></span>x=peek.pairs.@, glue(first.first.x, ?[ @~0 != @~1, @~1 : second.x ])
</pre></div>


<h2 id="recursive-functions">Recursive functions</h2>
<h4 id="compute-the-factorial">Compute the factorial:</h4>
<div class="codehilite"><pre><span></span>def fac &lt;&lt; @~0 * @~1 : 1, count.@ &gt;&gt;, fac.12
</pre></div>


<h4 id="a-32-bit-number-with-only-the-odd-bits-flipped">A 32-bit number with only the odd bits flipped:</h4>
<div class="codehilite"><pre><span></span>&lt;&lt; lsh(@~0, 2) | 1 : 0, count.32 &gt;&gt;
</pre></div>


<h4 id="the-11th-fibonacci-number">The 11th Fibonacci number:</h4>
<div class="codehilite"><pre><span></span>&lt;&lt; a=@~0~0, b=@~0~1, tuple(b, a + b) : tuple(0, 1), count.10 &gt;&gt;~1
</pre></div>


<h4 id="return-the-tail-of-a-sequence-like-the-unix-tool-tail">Return the tail of a sequence, like the Unix tool <code>tail</code>:</h4>
<div class="codehilite"><pre><span></span>def tail &lt;&lt; @~1 : peek.ngrams.@ &gt;&gt;, tail(@, 10)
</pre></div>


<h4 id="run-the-famous-rule-110-for-8-steps">Run the famous Rule 110 for 8 steps:</h4>
<div class="codehilite"><pre><span></span>def step [ t=string.@, case(t; &#39;XXX&#39;,&#39;.&#39;; &#39;X..&#39;,&#39;.&#39;; &#39;...&#39;,&#39;.&#39;; &#39;X&#39;) : ngrams(seq.bytes.@,3) ];
def rule110 &lt;&lt; cat(&#39;.&#39;, join(@~0, &#39;&#39;), &#39;.&#39;) : @~0, count.@~1 &gt;&gt;;
rule110(&#39;..........XX..........&#39;, 8)
</pre></div></body></html>
